---
---
@inproceedings{DBLP:conf/fase/SoueidiEF23,
  author       = {Chukri Soueidi and
                  Antoine El{-}Hokayem and
                  Yli{\`{e}}s Falcone},
                      abbr={FASE},
  editor       = {Leen Lambers and
                  Sebasti{\'{a}}n Uchitel},
  title        = {Opportunistic Monitoring of Multithreaded Programs},
  booktitle    = {Fundamental Approaches to Software Engineering - 26th International
                  Conference, {FASE} 2023, Held as Part of the European Joint Conferences
                  on Theory and Practice of Software, {ETAPS} 2023, Paris, France, April
                  22-27, 2023, Proceedings},
  series       = {Lecture Notes in Computer Science},
  volume       = {13991},
  pages        = {173--194},
  publisher    = {Springer},
  year         = {2023},
  url          = {https://doi.org/10.1007/978-3-031-30826-0\_10},
  doi          = {10.1007/978-3-031-30826-0\_10},
  timestamp    = {Sat, 29 Apr 2023 19:25:03 +0200},
  biburl       = {https://dblp.org/rec/conf/fase/SoueidiEF23.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/sac/SoueidiF22,
   bibtex_show={true},
     abbr={SAC-SVT},
  author    = {Chukri Soueidi and
               Yli{\`{e}}s Falcone},
  editor    = {Jiman Hong and
               Miroslav Bures and
               Juw Won Park and
               Tom{\'{a}}s Cern{\'{y}}},
  title     = {Capturing program models with {BISM}},
  booktitle = {{SAC} '22: The 37th {ACM/SIGAPP} Symposium on Applied Computing, Virtual
               Event, April 25 - 29, 2022},
  pages     = {1857--1861},
  publisher = {{ACM}},
  year      = {2022},
  url       = {https://doi.org/10.1145/3477314.3507239},
  doi       = {10.1145/3477314.3507239},
  timestamp = {Sun, 12 Feb 2023 00:00:00 +0100},
  biburl    = {https://dblp.org/rec/conf/sac/SoueidiF22.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  abstract={In this paper, we present an extension of the Java bytecode instrumentation tool BISM that captures and prepares a model that abstracts the program behavior at the intra-procedural level. We analyze program methods we are interested in monitoring and construct a control-flow graph automaton where the states represent actions of the program that produce events. Directed towards monitoring general behavioral properties at runtime, the resulting model is presented for the users to write static analyzers and combine both static and runtime verification.}

}

@inproceedings{DBLP:conf/vstte/SoueidiF22,
   bibtex_show={true},
     abbr={VSTTE},
  author    = {Chukri Soueidi and
               Yli{\`{e}}s Falcone},
  editor    = {Akash Lal and
               Stefano Tonetta},
  title     = {Residual Runtime Verification via Reachability Analysis},
  booktitle = {Verified Software. Theories, Tools and Experiments - 14th International
               Conference, {VSTTE} 2022, Trento, Italy, October 17-18, 2022},
  series    = {Lecture Notes in Computer Science},
  volume    = {13800},
  pages     = {148--166},
  publisher = {Springer},
  year      = {2022},
  url       = {https://doi.org/10.1007/978-3-031-25803-9\_9},
  doi       = {10.1007/978-3-031-25803-9\_9},
  timestamp = {Sat, 25 Feb 2023 00:00:00 +0100},
  biburl    = {https://dblp.org/rec/conf/vstte/SoueidiF22.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org},  
  selected={true},
  abstract={We leverage static verification to reduce monitoring overhead when runtime verifying a property. We present a sound and efficient analysis to statically find safe execution paths in the control flow at the intra-procedural level of programs. Such paths are guaranteed to preserve the monitored property and thus can be ignored at runtime. Our analysis guides an instrumentation tool to select program points that should be observed at runtime. The monitor is left to perform residual runtime verification for parts of the program that the analysis could not statically prove safe. Our approach does not depend on dataflow analysis, thus separating the task of residual analysis from static analysis; allowing for seamless integration with many RV frameworks and development pipelines. We implement our approach within BISM, which is a recent tool for bytecode-level instrumentation of Java programs. Our experiments on the DaCapo benchmark show a reduction in instrumentation points by a factor of 2.5 on average (reaching 9), and accordingly, a reduction in the number of runtime events by a factor of 1.8 on average (reaching 6).}
}

@article{DBLP:journals/corr/abs-2106-01115,
  abbr={CoRR},
   bibtex_show={true},
  author    = {Chukri Soueidi and
               Marius Monnier and
               Ali Kassem and
               Yli{\`{e}}s Falcone},
  title     = {Efficient and Expressive Bytecode-Level Instrumentation for Java Programs},
  journal   = {CoRR},
  volume    = {abs/2106.01115},
  year      = {2021},
  url       = {https://arxiv.org/abs/2106.01115},
  eprinttype = {arXiv},
  eprint    = {2106.01115},
  timestamp = {Thu, 10 Jun 2021 01:00:00 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/abs-2106-01115.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  abstract={We present an efficient and expressive tool for the instrumentation of Java programs at the bytecode level. BISM (Bytecode-Level Instrumentation for Software Monitoring) is a lightweight Java bytecode instrumentation tool that features an expressive high-level control-flow-aware instrumentation language. The instrumentation language is inspired by the aspect-oriented programming paradigm in modularizing instrumentation into separate transformers that encapsulate joinpoint selection and advice inlining, that is the selection of points of interest in the execution and the execution of additional code at these points, respectively. BISM allows capturing joinpoints ranging from bytecode instructions to methods execution and provides comprehensive static and dynamic context information. It runs in two instrumentation modes: build-time and load-time. BISM also provides a mechanism to compose transformers and automatically detect when they interfere on the base program. Transformers in a composition can control the visibility of their advice and other instructions from the base program. We show several example applications for BISM and demonstrate its effectiveness using three experiments: a security scenario, a financial transaction system, and a general runtime verification case. The results show that (i) BISM instrumentation incurs low runtime and memory overheads and (ii) the code produced by BISM performs better than the one produced by existing Java instrumentation tools.}
}

@inproceedings{DBLP:conf/rv/SoueidiKF20,
  abbr={RV},
   bibtex_show={true},
  author    = {Chukri Soueidi and
               Ali Kassem and
               Yli{\`{e}}s Falcone},
  editor    = {Jyotirmoy Deshmukh and
               Dejan Nickovic},
  title     = {{BISM:} Bytecode-Level Instrumentation for Software Monitoring},
  booktitle = {Runtime Verification - 20th International Conference, {RV} 2020, Los
               Angeles, CA, USA, October 6-9, 2020, Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {12399},
  pages     = {323--335},
  publisher = {Springer},
  year      = {2020},
  url       = {https://doi.org/10.1007/978-3-030-60508-7\_18},
  doi       = {10.1007/978-3-030-60508-7\_18},
  timestamp = {Sun, 12 Feb 2023 00:00:00 +0100},
  biburl    = {https://dblp.org/rec/conf/rv/SoueidiKF20.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  abstract={BISM (Bytecode-Level Instrumentation for Software Monitoring) is a lightweight Java bytecode instrumentation tool which features an expressive high-level control-flow-aware instrumentation language. The language follows the aspect-oriented programming paradigm by adopting the joinpoint model, advice inlining, and separate instrumentation mechanisms. BISM provides joinpoints ranging from bytecode instruction to method execution, access to comprehensive context information, and instrumentation methods. BISM runs in two modes: build-time and load-time. We demonstrate BISM effectiveness using two experiments: a security scenario and a general runtime verification case. The results show that BISM instrumentation incurs low runtime and memory overheads.}
}

 @article{soueidi_2015, 
   abbr={PACKT},
    bibtex_show={true},
 title={Microsoft Azure Storage Essentials}, 
 publisher={Packt Publishing}, 
 author={Soueidi, Chukri}, 
 year={2015},
 abstract={ A book intended for professionals looking for cloud data management solutions (NoSQL Tables, Blob Storage, Queues, and File Sharing). It is fast-paced, practical, and shows the quickest way to start using Azure storage solutions in real-world applications.},
 url={https://www.packtpub.com/product/microsoft-azure-storage-essentials/9781784396237?utm_source=google&utm_medium=cpc&utm_campaign=18331805515&utm_content=621682243179&utm_term=packt%20books&utm_tm=true},
 } 

@article{aubBehaviouralModeling,
	author = {Chukri Soueidi},
	title = {{B}ehavioural modeling and abstraction of concurrent programs.},
	howpublished = {\url{https://scholarworks.aub.edu.lb/handle/10938/21795}},
	year = {2019}, 
  booktitle = {American University of Beirut Master Thesis in Computer Science},
    pdf={t-7054.pdf},
    abbr={MS},
    abstract={We address the problem of modeling, analyzing, and repairing finite-state and infinite-state concurrent programs. We define a textual notation for concurrent programs and implement it in the Eshmun tool. For finite-state programs, we automatically generate Kripke structures (transition diagrams) from the program text. This structure can then be model checked and repaired using Eshmun facilities. The resulting repair can then be used to guide the designer in fixing the program itself. For infinite-state programs, we define the notion of a finitely-representable infinite-state Kripke structure, and we provide a semi-automatic method for generating such a structure from an infinite-state concurrent program. This structure models the behavior of the infinite state concurrent program. We label the states of the Kripke structure with state predicates, and the transitions with preconditions P and postconditions Q. Each transition τ then generates a Hoare triple [P] τ [Q] which we verify using the Z3 SMT solver. Hoare triples that are not valid must be repaired. When all triples are valid, we model check to determine if the required properties hold. If the model check fails, more repair is needed. If the model check succeeds, we can semi-automatically extract a correct infinite state concurrent program.}
 
}